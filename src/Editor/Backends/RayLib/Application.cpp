//=============================================================================
// TimedPetriNetEditor: A timed Petri net editor.
// Copyright 2021 -- 2023 Quentin Quadrat <lecrapouille@gmail.com>
//
// This file is part of TimedPetriNetEditor.
//
// TimedPetriNetEditor is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
//=============================================================================

#include "Editor/Backends/RayLib/Application.hpp"
#include "project_info.hpp" // generated by MyMakefile

#include <cstdlib>
#include <functional>
#include <chrono>
#include <stdio.h>

#include <fstream>
#include <iostream>
#include <cstdio>

#ifdef __APPLE__
#  define GET_DATA_PATH osx_get_resources_dir("data")
#else
#  define GET_DATA_PATH project::info::data_path
#endif

#ifdef __EMSCRIPTEN__
#  define FONT_SIZE 18.0f
#else
#  define FONT_SIZE 13.0f
#endif

class Timer
{
public:
    Timer()
        : m_begin(Clock::now())
    {}

    float restart()
    {
        float res = elapsed();
        m_begin = Clock::now();
        return res;
    }

    float elapsed() const
    {
        return std::chrono::duration_cast<Second>(Clock::now() - m_begin).count();
    }

private:
    typedef std::chrono::steady_clock Clock;
    typedef std::chrono::duration<float, std::ratio<1>> Second;
    std::chrono::time_point<Clock> m_begin;
};

//------------------------------------------------------------------------------
Application::Application(size_t const width, size_t const height, std::string const& title)
    : m_path(GET_DATA_PATH)
{
#ifdef __EMSCRIPTEN__
    m_path.add("data");
#endif

    m_screen_resolution.x = 0.0f;
    m_screen_resolution.y = 0.0f;
    m_screen_resolution.width = int(width);
    m_screen_resolution.height = int(height);

    SetConfigFlags(FLAG_WINDOW_RESIZABLE | FLAG_WINDOW_HIGHDPI);
    InitWindow(m_screen_resolution.width, m_screen_resolution.height, title.c_str());

    Vector2 windowPosition = { 500, 200 };
    SetWindowPosition(windowPosition.x, windowPosition.y);
    SetTargetFPS(60);

    // Setup Dear ImGui context
    ImGui::CreateContext();
    ImPlot::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;    // Enable Keyboard Controls
    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;       // Enable Docking

    // Setup fonts
    io.Fonts->AddFontFromFileTTF(m_path.expand("font.ttf").c_str(), FONT_SIZE);

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    //ImGui::StyleColorsLight();

    // Setup Platform/Renderer backends
    ImGui_ImplRaylib_Init();
}

//------------------------------------------------------------------------------
Application::~Application()
{
    ImGui_ImplRaylib_Shutdown();
    ImPlot::DestroyContext();
    ImGui::DestroyContext();

    CloseWindow(); // Stop raylib
}

//------------------------------------------------------------------------------
void Application::run()
{
    // Initialize the underlying app
    onStartUp();

    //Timer timer;
    //float timeSinceLastUpdate = 0.0f;
    const float time_per_frame = 1.0f / m_framerate;
    while (!m_exit_window && !WindowShouldClose())
    {
        ImGui_ImplRaylib_ProcessEvents();

        // Start the Dear ImGui frame
        ImGui_ImplRaylib_NewFrame();
        ImGui::NewFrame();

        // Process events at fixed time steps
        //timeSinceLastUpdate += timer.restart();
        //while (timeSinceLastUpdate > time_per_frame)
        //{
            //timeSinceLastUpdate -= time_per_frame;
            onUpdate(time_per_frame);
        //}

        // Main loop of the underlying app
        onDraw();

        // Rendering
        ImGui::Render();
        BeginDrawing(); // Start raylib content
        ClearBackground(WHITE);//gui->background_color);

        ImGui_ImplRaylib_RenderDrawData(ImGui::GetDrawData());
        EndDrawing(); // Stop raylib content
    }
}

//------------------------------------------------------------------------------
void Application::framerate(size_t const framerate)
{
    m_framerate = framerate;
    SetTargetFPS(m_framerate);
}

//------------------------------------------------------------------------------
// Siiiiiight! Poor RayLib API. Only manage file name not file path :(
// TakeScreenshot has been hot patched to use with absolute path.
bool Application::screenshot(std::string const& path)
{
    TakeScreenshot(path.c_str());
    return FileExists(path.c_str());
}