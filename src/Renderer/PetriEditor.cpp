//=============================================================================
// TimedPetriNetEditor: A timed Petri net editor.
// Copyright 2021 -- 2023 Quentin Quadrat <lecrapouille@gmail.com>
//
// This file is part of TimedPetriNetEditor.
//
// TimedPetriNetEditor is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
//=============================================================================

#include "Renderer/PetriEditor.hpp"
#include "TimedPetriNetEditor/Algorithms.hpp"
#include "Net/Formats/Exports.hpp"
#include "Net/Formats/Imports.hpp"
#include "Net/SparseMatrix.hpp"
#include "project_info.hpp" // generated by MyMakefile
#include <iomanip> // std::setprecision

namespace tpne {

//------------------------------------------------------------------------------
// states for dear im gui
static bool do_dater = false;
static bool do_counter = false;
static bool do_find_critical_cycle = false;
static bool do_syslin = false;
static bool do_adjency = false;
static bool do_load = false;
static bool do_save_as = false;
static Exporter const* do_export_to = nullptr;
static bool show_about = false;
static bool show_help = false;

static std::vector<Exporter> const exporters = {
    { "Grafcet C++", ".hpp,.h,.hh,.h++", exportToGrafcetCpp },
    { "Symfony", ".yaml", exportToSymfony },
    { "Julia", ".jl", exportToJulia },
    { "Draw.io", ".drawio.xml", exportToDrawIO },
    { "Graphviz", ".gv,.dot", exportToGraphviz },
    { "PN-Editor", ".pns,.pnl,.pnk,.pnkp", exportToPNEditor },
    { "Petri-LaTeX", ".tex", exportToPetriLaTeX },
    //{ "Codesys", ".codesys.xml", exportToCodesys },
    //{ "Grafcet-LaTeX", ".tex", exportToGrafcetLaTeX },
};

//------------------------------------------------------------------------------
// Config for rendering the Petri net
const float TRANS_WIDTH = 25.0f;  // Rectangle width for rendering Transitions
const float TRANS_HEIGHT = TRANS_WIDTH / 2.0f;  // Rectangle height for rendering Transitions
const float PLACE_RADIUS = TRANS_WIDTH / 2.0f; // Circle radius for rendering Places
const float TOKEN_RADIUS = 2.0f;  // Circle radius for rendering tokens
const float CAPTION_FONT_SIZE = 12;
#define FILL_COLOR(a) IM_COL32(255, 165, 0, (a))
#define OUTLINE_COLOR IM_COL32(165, 42, 42, 255) // Arcs, Places, Transitions
#define CRITICAL_COLOR IM_COL32(255, 0, 0, 255)

const uint8_t alpha = 255; // FIXME

//------------------------------------------------------------------------------
// helper functions
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

//------------------------------------------------------------------------------
static void about()
{
    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::OpenPopup("About TimedPetriNetEditor");
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("About TimedPetriNetEditor", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("A timed Petri net and graph event editor and");
        ImGui::Text("simulator combined to (max,+) algebra with");
        ImGui::Text("wrapped API for Julia langage.");
        ImGui::Separator();
        std::string version("Version: " +
                            std::to_string(project::info::major_version) + '.' +
                            std::to_string(project::info::minor_version) + '.' +
                            std::to_string(project::info::patch_version));
        ImGui::Text("%s", version.c_str());
        ImGui::Separator();
        ImGui::Text("https://github.com/Lecrapouille/TimedPetriNetEditor");
        ImGui::Text("Git branch: %s", project::info::git_branch.c_str());
        ImGui::Text("Git SHA1: %s", project::info::git_sha1.c_str());
        ImGui::Text("Compiled as %s",
                    (project::info::mode == project::info::Mode::debug)
                    ? "Debug" : "Release");
        ImGui::Separator();
        ImGui::Text("Developed by Quentin Quadrat");
        ImGui::Text("Email: lecrapouille@gmail.com");
        ImGui::Separator();

        if (ImGui::Button("OK", ImVec2(120, 0)))
        {
            ImGui::CloseCurrentPopup();
            show_about = false;
        }

        ImGui::EndPopup();
    }
}

//------------------------------------------------------------------------------
static void help()
{
    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::OpenPopup("Help TimedPetriNetEditor");
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("Help TimedPetriNetEditor", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
        if (ImGui::BeginTabBar("help", tab_bar_flags))
        {
            if (ImGui::BeginTabItem("Mouse actions"))
            {
                std::stringstream help;
                help << "Left button pressed: add a place" << std::endl
                << "Right button pressed: add a transition" << std::endl
                << "Middle button pressed: add an arc with the selected place or transition as origin" << std::endl
                << "Middle button release: end the arc with the selected place or transition as destination" << std::endl
                << "Middle button pressed: move the view" << std::endl;

                ImGui::Text("%s", help.str().c_str());
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Keyboard actions"))
            {
                std::stringstream help;
                help << "Not yet implemented" << std::endl;

                ImGui::Text("%s", help.str().c_str());
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Pathes"))
            {
                ImGui::Text("Data path: %s", project::info::data_path.c_str());
                ImGui::Text("Temporary path: %s", project::info::tmp_path.c_str());
                ImGui::Text("Log path: %s", project::info::log_path.c_str());
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }

        if (ImGui::Button("OK", ImVec2(120, 0)))
        {
            ImGui::CloseCurrentPopup();
            show_help = false;
        }

        ImGui::EndPopup();
    }
}

//------------------------------------------------------------------------------
static void console(Editor& editor)
{
    ImGui::Begin("Console");
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 6.f);
    if (ImGui::Button("Clear##console_clear")) {
        editor.clearLogs();
    }

    ImGui::PopStyleVar();
    ImGui::Spacing();
    auto const& logs = editor.getLogs();
    size_t i = logs.size();
    while (i--)
    {
        ImGui::Separator();
        if (logs[i].level == Messages::Level::Info)
        {
            ImGui::TextColored(ImVec4(0, 255, 0, 255), "%s[info]: %s",
                 logs[i].time.c_str(), logs[i].message.c_str());
        }
        else if (logs[i].level == Messages::Level::Error)
        {
            ImGui::TextColored(ImVec4(255, 0, 0, 255), "%s[error]: %s",
            logs[i].time.c_str(), logs[i].message.c_str());
        }
        else
        {
            ImGui::TextColored(ImVec4(255, 0, 255, 255), "%s[warn]: %s",
            logs[i].time.c_str(), logs[i].message.c_str());
        }
    }
    ImGui::End();
}

//------------------------------------------------------------------------------
static void messagebox(Editor const& editor)
{
    ImGui::Begin("Message");
    ImGui::Text("%s", editor.getError().c_str()); // FIXME: by copy
    ImGui::End();
}

//------------------------------------------------------------------------------
static void menu(Editor& editor)
{
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("New", nullptr, false)) {
                // TODO
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Open", nullptr, false)) {
                do_load = true;
            }
            if (ImGui::BeginMenu("Import"))
            {
                // TODO
                ImGui::EndMenu();
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Save", nullptr, false))
            {
                if (editor.m_net.filename() == "") {
                    do_save_as = true;
                } else {
                    editor.m_net.saveAs(editor.m_net.filename());
                }
            }
            if (ImGui::MenuItem("Save As", nullptr, false)) {
                do_save_as = true;
            }
            if (ImGui::BeginMenu("Export to"))
            {
                for (auto const& it: exporters)
                {
                    if (ImGui::MenuItem(it.format.c_str(), nullptr, false))
                    {
                        do_export_to = &it;
                    }
                }
                ImGui::EndMenu();
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Exit", nullptr, false)) {
                editor.close();
            }
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Actions"))
        {
            if (ImGui::BeginMenu("Type of net"))
            {
                static int current_type = int(editor.m_net.type());

                ImGui::RadioButton("Petri net", &current_type, 0);
                ImGui::RadioButton("Timed Petri net", &current_type, 1);
                ImGui::RadioButton("Timed event graph", &current_type, 2);
                ImGui::RadioButton("GRAFCET", &current_type, 3);
                editor.changeTypeOfNet(TypeOfNet(current_type));
                ImGui::EndMenu();
            }
            ImGui::Separator();

            if (ImGui::MenuItem("Clear net", nullptr, false)) {
                editor.clear();
            }
            if (ImGui::MenuItem("Align nodes", nullptr, false))
            {}//editor.align();
            if (ImGui::MenuItem("Show grid", nullptr, false)) {
                editor.m_layout_config.grid.enable ^= true;
            }
            if (ImGui::MenuItem("Take screenshot", nullptr, false))
            {}//editor.screenshot();
            ImGui::Separator();
            //if (ImGui::MenuItem("Run", nullptr, false)) TODO
            //    editor.run();
            //if (ImGui::MenuItem("Stop", nullptr, false)) TODO
            //    editor.stop();
            ImGui::EndMenu();
        }

        if ((editor.m_net.type() == TypeOfNet::TimedEventGraph) ||
            (isEventGraph(editor.m_net)))
        {
            if (ImGui::BeginMenu("Graph Events"))
            {
                if (ImGui::MenuItem("Show critical circuit", nullptr, false))
                {
                    do_find_critical_cycle = true;
                }
                if (ImGui::MenuItem("Show (max, +) dynamic linear system", nullptr, false))
                {
                    do_syslin = true;
                }
                if (ImGui::MenuItem("Show Dater equation", nullptr, false))
                {
                    do_dater = true;
                }
                if (ImGui::MenuItem("Show Counter equation", nullptr, false))
                {
                    do_counter = true;
                }
                if (ImGui::MenuItem("Show adjacency matrices", nullptr, false))
                {
                    do_adjency = true;
                }
                ImGui::EndMenu();
            }
        }
        if (ImGui::BeginMenu("Help"))
        {
            if (ImGui::MenuItem("Help", nullptr, false)) {
                show_help = true;
            }
            ImGui::Separator();
            if (ImGui::MenuItem("About", nullptr, false)) {
                show_about = true;
            }
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }

    if (show_help) { help(); }
    if (show_about) { about(); }
    if (do_load) { editor.load(); }
    if (do_save_as) { editor.saveAs(); }
    if (do_export_to != nullptr) { editor.exportTo(*do_export_to); }

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();

    if (do_adjency)
    {
        ImGui::OpenPopup("Show adjacency matrices");
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal("Show adjacency matrices",
                                   NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Dense matrix", &SparseMatrix<double>::display_as_dense);
            SparseMatrix<double>::display_for_julia = false;
            ImGui::PopStyleVar();

            SparseMatrix<double> tokens; SparseMatrix<double> durations;
            toAdjacencyMatrices(editor.m_net, tokens, durations);

            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("adjacency", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("Durations"))
                {
                    std::stringstream txt; txt << durations;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Tokens"))
                {
                    std::stringstream txt; txt << tokens;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }

            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_adjency = false;
            }
            ImGui::EndPopup();
        }
    }

    if (do_counter || do_dater)
    {
        const char* title = do_counter ? "Counter Equation": "Dater Equation";
        ImGui::OpenPopup(title);
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal(title, NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            static bool use_caption = false;
            static bool maxplus_notation = false;
            static bool show_matrix = false;
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox(do_counter ? "Use (min,+) operator" : "Use (max,+) operator", &maxplus_notation);
            ImGui::SameLine();
            ImGui::Checkbox("Use caption", &use_caption);
            ImGui::PopStyleVar();

            ImGui::Separator();
            if (do_counter)
            {
                ImGui::Text("%s", showCounterEquation(editor.m_net, "", use_caption, maxplus_notation).str().c_str());
            }
            else
            {
                ImGui::Text("%s", showDaterEquation(editor.m_net, "", use_caption, maxplus_notation).str().c_str());
            }

            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_counter = do_dater = false;
            }
            ImGui::EndPopup();
        }
    }

    if (do_syslin)
    {
        ImGui::OpenPopup("(max, +) dynamic linear system");
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal("(max, +) dynamic linear system", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Dense matrix", &SparseMatrix<double>::display_as_dense);
            ImGui::PopStyleVar();

            SparseMatrix<double> D; SparseMatrix<double> A; SparseMatrix<double> B; SparseMatrix<double> C;
            toSysLin(editor.m_net, D, A, B, C);
            SparseMatrix<double>::display_for_julia = false;
            ImGui::Text(u8"%s", "X(n) = D . X(n) ⨁ A . X(n-1) ⨁ B . U(n)\nY(n) = C . X(n)");
            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("syslin", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("D"))
                {
                    std::stringstream txt; txt << D;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("A"))
                {
                    std::stringstream txt; txt << A;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("B"))
                {
                    std::stringstream txt; txt << B;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("C"))
                {
                    std::stringstream txt; txt << C;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }

            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_syslin = false;
            }
            ImGui::EndPopup();
        }
    }

    if (do_find_critical_cycle)
    {
        ImGui::OpenPopup("Critical Cycle");
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal("Critical Cycle", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            CriticalCycleResult critical_cycle = findCriticalCycle(editor.m_net);
            if (!critical_cycle.success)
            {
                ImGui::Text(u8"%s", critical_cycle.message.str().c_str());
            }
            else
            {
                ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
                if (ImGui::BeginTabBar("CriticalCycleResult", tab_bar_flags))
                {
                    if (ImGui::BeginTabItem("Critical cycle"))
                    {
                        std::stringstream txt;
                        if (editor.m_net.type() == TypeOfNet::TimedEventGraph)
                        {
                            // Only show transitions
                            for (auto const& it: critical_cycle.arcs)
                            {
                                if (it->from.type == Node::Type::Transition)
                                    txt << it->from.key << " -> ";
                                if (it->to.type == Node::Type::Transition)
                                    txt << it->to.key << std::endl;
                            }
                        }
                        else
                        {
                            // Show transitions and places
                            for (auto const& it: critical_cycle.arcs)
                            {
                                txt << it->from.key << " -> " << it->to.key << std::endl;
                            }
                        }
                        ImGui::Text("%s", txt.str().c_str());
                        ImGui::EndTabItem();
                    }
                    if (ImGui::BeginTabItem("Cycle time"))
                    {
                        const auto& tr = editor.m_net.transitions();
                        std::stringstream txt;
                        for (size_t i = 0u; i < critical_cycle.cycle_time.size(); ++i)
                        {
                            txt << tr[i].key << ": " << critical_cycle.cycle_time[i]
                                << " unit of time" << std::endl;
                        }
                        ImGui::Text("%s", txt.str().c_str());
                        ImGui::EndTabItem();
                    }
                    if (ImGui::BeginTabItem("Eigenvector"))
                    {
                        std::stringstream txt;
                        for (auto const& it: critical_cycle.eigenvector)
                        {
                            txt << it << std::endl;
                        }
                        ImGui::Text("%s", txt.str().c_str());
                        ImGui::EndTabItem();
                    }
                    ImGui::EndTabBar();
                }
            }

            ImGui::Separator();
            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_find_critical_cycle = false;
            }
            ImGui::EndPopup();
        }
    }
}

//--------------------------------------------------------------------------
Editor::Editor(size_t const width, size_t const height,
               std::string const& title, std::string const& filename)
    : Application(width, height, title), m_filename(filename)
{}

//------------------------------------------------------------------------------
void Editor::onStartUp()
{
    if (m_filename.empty())
        return ;

    if (m_net.load(m_filename))
    {
        m_messages.setInfo("loaded with success " + m_filename);
    }
    else
    {
        m_messages.setError(m_net.error());
    }
}

//------------------------------------------------------------------------------
void Editor::reshape()
{
    // ImDrawList API uses screen coordinates!
    canvas_p0 = ImGui::GetCursorScreenPos();
    // Resize canvas to what's available
    canvas_sz = ImGui::GetContentRegionAvail();
    if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;
    if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;
    canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Lock scrolled origin
    origin = ImVec2(canvas_p0.x + scrolling.x, canvas_p0.y + scrolling.y);
}

//------------------------------------------------------------------------------
void Editor::drawGrill()
{
    draw_list->ChannelsSetCurrent(0); // Background
    draw_list->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(50, 50, 50, 255));
    draw_list->AddRect(canvas_p0, canvas_p1, IM_COL32(255, 255, 255, 255));

    if (!m_layout_config.grid.enable)
        return ;

    const float step = m_layout_config.grid.step;
    for (float x = fmodf(scrolling.x, step); x < canvas_sz.x; x += step)
    {
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y),
                           ImVec2(canvas_p0.x + x, canvas_p1.y),
                           IM_COL32(200, 200, 200, 40));
    }

    for (float y = fmodf(scrolling.y, step); y < canvas_sz.y; y += step)
    {
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y),
                           ImVec2(canvas_p1.x, canvas_p0.y + y),
                           IM_COL32(200, 200, 200, 40));
    }
}

//------------------------------------------------------------------------------
void Editor::drawPetriNet()
{
    static bool open;
    if (!ImGui::Begin("Petri net: foo bar", &open))
    {
        ImGui::End();
        return;
    }

    reshape();
    drag();

    draw_list = ImGui::GetWindowDrawList();
    draw_list->ChannelsSplit(2);

    draw_list->PushClipRect(canvas_p0, canvas_p1, true);

    drawGrill();
    for (auto const& it: m_net.arcs()) {
        drawArc(it);
    }
    for (auto const& it: m_net.places()) {
        drawPlace(it);
    }
    for (auto const& it: m_net.transitions()) {
        drawTransition(it);
    }

    draw_list->PopClipRect();

    ImGui::End();
}

//------------------------------------------------------------------------------
void Editor::onDraw()
{
    ImGui::DockSpaceOverViewport();

    ::tpne::menu(*this);
    ::tpne::console(*this);
    ::tpne::messagebox(*this);

    drawPetriNet();
}

//------------------------------------------------------------------------------
static inline float norm(const float xa, const float ya, const float xb, const float yb)
{
    return sqrtf((xb - xa) * (xb - xa) + (yb - ya) * (yb - ya));
}

static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)
{
    return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a);
}

//------------------------------------------------------------------------------
static void drawArrow(ImDrawList* draw_list, const float xa, const float ya,
   const float xb, const float yb, const ImU32 color)
{
    // Orientation
    const float teta = (yb - ya) / (xb - xa);
    const float arrowAngle = std::atan(teta);
    const float cos_a = std::cos(arrowAngle);
    const float sin_a = std::sin(arrowAngle);

    // Arc magnitude
    const float arrowLength = norm(xa, ya, xb, yb);

    // Reduce the arrow magnitude to avoid entering in the place and having
    // a mush of pixels when multiple arrows are pointing on the same
    // position. To get full scaled arrow comment this block of code and
    // uncomment xa, xb, ya, yb and tailSize.
    const float r = arrowLength - PLACE_RADIUS;
    const float dx = ((xb - xa) * r) / arrowLength;
    const float dy = ((yb - ya) * r) / arrowLength;
    const float a1 = xb - dx;
    const float b1 = yb - dy;
    const float a2 = xa + dx;
    const float b2 = ya + dy;

    // Head of the arrow
    const ImVec2 arrowHeadSize(14.0f, 14.0f);
    std::vector<ImVec2> points = {
        ImVec2(a2, b2 /*xb, yb*/) + ImRotate(ImVec2(0.0f, 0.0f), cos_a, sin_a),
        ImVec2(a2, b2 /*xb, yb*/) + ImRotate(ImVec2(arrowHeadSize.x, arrowHeadSize.y / 2.0f), cos_a, sin_a),
        ImVec2(a2, b2 /*xb, yb*/) + ImRotate(ImVec2(0.0f, arrowHeadSize.y), cos_a, sin_a)
    };
    draw_list->AddConvexPolyFilled(points.data(), points.size(), color);

    // Tail of the arrow.
    //const sf::Vector2f tailSize{ arrowLength - arrowHeadSize.x, 2.f };
    const ImVec2 tailSize(r - arrowHeadSize.x - 15.0f, 2.0f);
    draw_list->AddLine(ImVec2(xa, ya), ImVec2(xb, yb), color, 2.0f);
}

//------------------------------------------------------------------------------
void Editor::drawArc(Arc const& arc)
{
    ImU32 color;

    if (alpha >= 0u)
    {
        color = FILL_COLOR(alpha);
    }
    else
    {
        // hack to show critical cycles
        color = CRITICAL_COLOR;
    }

    if (m_net.type() == TypeOfNet::TimedEventGraph)
    {
        // In graph event we "compress" the graph by not displaying places.
        if (arc.from.type == Node::Type::Place)
            return ;

        // We draw arrows between Transition to Transition using the
        // property of graph event: there is only one place between them.
        assert((arc.to.arcsOut.size() == 1u) && "malformed graph event");
        Node& next = arc.to.arcsOut[0]->to;
        drawArrow(draw_list,
                  origin.x + arc.from.x,
                  origin.y + arc.from.y,
                  origin.x + next.x,
                  origin.y + next.y,
                  color);

        // Print the timing / tokens
        float x = origin.x + arc.from.x + (next.x - arc.from.x) / 2.0f;
        float y = origin.y + arc.from.y + (next.y - arc.from.y) / 2.0f;
        std::stringstream stream;
        stream << std::fixed << std::setprecision(2) << arc.duration << ", "
               << arc.to.key << "(" << reinterpret_cast<Place&>(arc.to).tokens << ")";
        draw_list->AddText(ImVec2(x, y), IM_COL32(0, 0, 0, 255), stream.str().c_str());
    }
    else
    {
        // Transition -> Place
        drawArrow(draw_list,
                  origin.x + arc.from.x,
                  origin.y + arc.from.y,
                  origin.x + arc.to.x,
                  origin.y + arc.to.y, color);

        if ((arc.from.type == Node::Type::Transition) && (m_net.type() == TypeOfNet::TimedPetriNet))
        {
            // Print the timing for timed petri net
            float x = origin.x + arc.from.x + (arc.to.x - arc.from.x) / 2.0f;
            float y = origin.y + arc.from.y + (arc.to.y - arc.from.y) / 2.0f - 15.0f;
            std::stringstream stream;
            stream << std::fixed << std::setprecision(2) << arc.duration;
            draw_list->AddText(ImVec2(x, y), IM_COL32(0, 0, 0, 255), stream.str().c_str());
        }
    }
}

//------------------------------------------------------------------------------
void Editor::drawToken(float const x, float const y)
{
    draw_list->AddCircleFilled(ImVec2(x, y), TOKEN_RADIUS, IM_COL32(0, 0, 0, 255));
}

// TODO a virer en utilisant un wrapper RenderablePlace avec fading (alpha)
//------------------------------------------------------------------------------
void Editor::drawPlace(Place const& place)
{
    // In graph event we "compress" the graph by not displaying places.
    if (m_net.type() == TypeOfNet::TimedEventGraph)
        return ;

    //const uint8_t alpha = 255; // TODO m_fading[place.key]
    const ImVec2 p = origin + ImVec2(place.x, place.y);

    // Draw the place
    draw_list->AddCircleFilled(p, PLACE_RADIUS, FILL_COLOR(alpha), 64);
    draw_list->AddCircle(p, PLACE_RADIUS, OUTLINE_COLOR, 64);

    // Draw the caption
    ImVec2 dim = ImGui::CalcTextSize(place.key.c_str());
    ImVec2 ptext = p - ImVec2(dim.x / 2.0f, PLACE_RADIUS + dim.y);
    draw_list->AddText(ptext, IM_COL32(0, 0, 0, 255), place.key.c_str());

    // Draw the number of tokens
    if (place.tokens == 0u)
        return ;

    float r = TOKEN_RADIUS;
    float d = TOKEN_RADIUS + 1.0f;

    if (place.tokens == 1u)
    {
        drawToken(p.x, p.y);
    }
    else if (place.tokens == 2u)
    {
        drawToken(p.x - d, p.y);
        drawToken(p.x + d, p.y);
    }
    else if (place.tokens == 3u)
    {
        drawToken(p.x, p.y - r);
        drawToken(p.x - d, p.y + d);
        drawToken(p.x + d, p.y + d);
    }
    else if ((place.tokens == 4u) || (place.tokens == 5u))
    {
        if (place.tokens == 5u)
        {
            d = r + 3.0f;
            drawToken(p.x, p.y);
        }

        drawToken(p.x - d, p.y - d);
        drawToken(p.x + d, p.y - d);
        drawToken(p.x - d, p.y + d);
        drawToken(p.x + d, p.y + d);
    }
    else
    {
        std::string tokens = std::to_string(place.tokens);
        draw_list->AddText(ImVec2(p.x, p.y), IM_COL32(0, 0, 0, 255), tokens.c_str());
    }
}

//------------------------------------------------------------------------------
void Editor::drawTransition(Transition const& transition)
{
    //const uint8_t alpha = 255; // TODO m_fading[place.key]
    const ImVec2 p = origin + ImVec2(transition.x, transition.y);

    // Color of the transition: green if validated else yellow if enabled
    // else color is fadding value.
    ImU32 color;
    if ((m_net.type() == TypeOfNet::PetriNet) && (transition.isValidated()))
    {
        color = IM_COL32(255, 0, 0, 255);
    }
    else
    {
        color = FILL_COLOR(transition.isEnabled() ? 0 : alpha);
    }

    // Draw the transition
    const ImVec2 pmin(p.x - TRANS_WIDTH / 2.0f, p.y - TRANS_HEIGHT / 2.0f);
    const ImVec2 pmax(p.x + TRANS_WIDTH / 2.0f, p.y + TRANS_HEIGHT / 2.0f);
    draw_list->AddRectFilled(pmin, pmax, color);
    draw_list->AddRect(pmin, pmax + ImVec2(0.0f, 1.0f), OUTLINE_COLOR, 0, 5.0f);

    // Draw the caption
    ImVec2 dim = ImGui::CalcTextSize(transition.key.c_str());
    ImVec2 ptext = p - ImVec2(dim.x / 2.0f, TRANS_HEIGHT + dim.y);
    draw_list->AddText(ptext, IM_COL32(0, 0, 0, 255), transition.key.c_str());
}

//------------------------------------------------------------------------------
ImVec2 Editor::mouse()
{
    ImGuiIO& io = ImGui::GetIO();
    return ImVec2(io.MousePos.x - origin.x, io.MousePos.y - origin.y);
}

//------------------------------------------------------------------------------
void Editor::drag()
{
    // This will catch our interactions
    ImGui::InvisibleButton("canvas", canvas_sz, ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight);
    const bool is_hovered = ImGui::IsItemHovered(); // Hovered
    const bool is_active = ImGui::IsItemActive();   // Held

    // Pan (we use a zero mouse threshold when there's no context menu)
    // You may decide to make that threshold dynamic based on whether the mouse is hovering something etc.
    const float mouse_threshold_for_pan = m_layout_config.grid.menu ? -1.0f : 0.0f;
    if (is_active && ImGui::IsMouseDragging(ImGuiMouseButton_Right, mouse_threshold_for_pan))
    {
        ImGuiIO& io = ImGui::GetIO();
        scrolling.x += io.MouseDelta.x;
        scrolling.y += io.MouseDelta.y;
    }
}

//------------------------------------------------------------------------------
void Editor::clear()
{
    m_simulating = false;
    m_net.clear(m_net.type());
    //TODO m_animated_tokens.clear();
}

//------------------------------------------------------------------------------
bool Editor::changeTypeOfNet(TypeOfNet const type)
{
    if (m_simulating)
        return false;

    std::vector<Arc*> arcs;
    if (m_net.convertTo(type, arcs))
        return true;

    m_messages.setError(m_net.error());
    return false;
}

//------------------------------------------------------------------------------
void Editor::load()
{
    if (m_simulating)
    {
        m_messages.setError("Cannot load during the simulation!");
        return ;
    }

    ImGuiFileDialog::Instance()->OpenDialog("ChooseFileDlgKey",
                                            "Choose the Petri file to load",
                                            ".json", ".", 1, nullptr,
                                            ImGuiFileDialogFlags_Modal);

    if (ImGuiFileDialog::Instance()->Display("ChooseFileDlgKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            if (m_net.load(ImGuiFileDialog::Instance()->GetFilePathName()))
            {
                m_messages.setInfo("loaded with success " +
                    ImGuiFileDialog::Instance()->GetFilePathName());
            }
            else
            {
                m_messages.setError(m_net.error());
            }
        }
        //else
        //{
        //    m_messages.setError("No selected file for loading");
        //}

        // close
        do_load = false;
        ImGuiFileDialog::Instance()->Close();
    }
}

//------------------------------------------------------------------------------
void Editor::exportTo(Exporter const& exporter)
{
    if (m_simulating)
    {
        m_messages.setError("Cannot save during the simulation!");
        return ;
    }

    ImGuiFileDialog::Instance()->OpenDialog("ChooseFileDlgKey",
                                            "Choose the Petri file to save",
                                            exporter.extensions.c_str(), ".", 1, nullptr, // nullptr, m_net.filename() + ".json", 1, nullptr,
                                            ImGuiFileDialogFlags_Modal | ImGuiFileDialogFlags_ConfirmOverwrite);

    if (ImGuiFileDialog::Instance()->Display("ChooseFileDlgKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            std::string error = exporter.exportFct(m_net, ImGuiFileDialog::Instance()->GetFilePathName());
            if (error.empty())
            {
                m_messages.setInfo("saved with success " +
                    ImGuiFileDialog::Instance()->GetFilePathName());
            }
            else
            {
                m_messages.setError(error);
            }
        }

        // close.
        do_save_as = false;
        do_export_to = nullptr; // FIXME think proper code: export vs save as
        ImGuiFileDialog::Instance()->Close();
    }
}

//------------------------------------------------------------------------------
void Editor::saveAs()
{
    static Exporter exporter{"TimedPetriNetEditor", ".json", exportToJSON};
    exportTo(exporter);
}

//------------------------------------------------------------------------------
void Editor::close()
{
}

} // namespace tpne
