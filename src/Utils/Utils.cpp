//=============================================================================
// TimedPetriNetEditor: A timed Petri net editor.
// Copyright 2021 -- 2023 Quentin Quadrat <lecrapouille@gmail.com>
//
// This file is part of TimedPetriNetEditor.
//
// TimedPetriNetEditor is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
//=============================================================================

#include "Utils/Utils.hpp"
#include "project_info.hpp" // generated by MyMakefile
#include <sys/stat.h>

#ifdef __APPLE__
#  include <CoreFoundation/CFBundle.h>
#endif

#  include <algorithm> // std::transform
#  include <random>

//------------------------------------------------------------------------------
#ifdef __APPLE__
std::string osx_get_resources_dir(std::string const& file)
{
    struct stat exists; // folder exists ?
    std::string path;

    CFURLRef resourceURL = CFBundleCopyResourcesDirectoryURL(CFBundleGetMainBundle());
    char resourcePath[PATH_MAX];
    if (CFURLGetFileSystemRepresentation(resourceURL, true,
                                         reinterpret_cast<UInt8 *>(resourcePath),
                                         PATH_MAX))
    {
        if (resourceURL != NULL)
        {
            CFRelease(resourceURL);
        }

        path = std::string(resourcePath) + "/" + file;
        if (stat(path.c_str(), &exists) == 0)
        {
            return path;
        }
    }

    path = "data/" + file;
    if (stat(path.c_str(), &exists) == 0)
    {
        return path;
    }

    return file;
}
#endif

namespace tpne {

//------------------------------------------------------------------------------
int randomInt(int lower, int upper)
{
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(lower, upper);
    return dist(gen);
}

//------------------------------------------------------------------------------
float randomFloat(int lower, int upper)
{
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_real_distribution<float> dist(lower, upper);
    return dist(gen);
}

//------------------------------------------------------------------------------
std::string extension(std::string const& path)
{
    std::string::size_type pos = path.find_last_of(".");
    if (pos != std::string::npos)
    {
        std::string ext = path.substr(pos /*+ 1*/, std::string::npos);

        // Ignore the ~ in the extension (ie. foo.txt~)
        if ('~' == ext.back())
            ext.pop_back();

        // Get the file extension in lower case
        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
        return ext;
    }
    return "";
}

//------------------------------------------------------------------------------
std::string baseName(std::string const& path)
{
    return path.substr(0, path.find_last_of("."));
}

} // namespace tpne