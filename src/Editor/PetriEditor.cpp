//=============================================================================
// TimedPetriNetEditor: A timed Petri net editor.
// Copyright 2021 -- 2023 Quentin Quadrat <lecrapouille@gmail.com>
//
// This file is part of TimedPetriNetEditor.
//
// TimedPetriNetEditor is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
//=============================================================================

#include "Editor/PetriEditor.hpp"
#include "Editor/KeyBindings.hpp"
#include "TimedPetriNetEditor/Algorithms.hpp"
#include "Net/Formats/Exports.hpp"
#include "Net/Formats/Imports.hpp"
#include "Net/SparseMatrix.hpp"
#include "project_info.hpp" // generated by MyMakefile
#include <iomanip> // std::setprecision

namespace tpne {

//------------------------------------------------------------------------------
// states for dear im gui
static bool is_dragging = false;
static bool disable_dragging = false;
static bool do_dater = false;
static bool do_counter = false;
static bool do_find_critical_cycle = false;
static bool do_syslin = false;
static bool do_adjency = false;
static bool do_load = false;
static bool do_save_as = false;
static bool do_screenshot = false;
static Exporter const* do_export_to = nullptr;
static bool show_about = false;
static bool show_help = false;
static bool show_place_captions = false;
static bool show_transition_captions = false;

static std::vector<Exporter> const exporters = {
    { "Grafcet C++", ".hpp,.h,.hh,.h++", exportToGrafcetCpp },
    { "Symfony", ".yaml", exportToSymfony },
    { "Julia", ".jl", exportToJulia },
    { "Draw.io", ".drawio.xml", exportToDrawIO },
    { "Graphviz", ".gv,.dot", exportToGraphviz },
    { "PN-Editor", ".pns,.pnl,.pnk,.pnkp", exportToPNEditor },
    { "Petri-LaTeX", ".tex", exportToPetriLaTeX },
    //{ "Codesys", ".codesys.xml", exportToCodesys },
    //{ "Grafcet-LaTeX", ".tex", exportToGrafcetLaTeX },
};

//------------------------------------------------------------------------------
// Config for rendering the Petri net
static float thickness = 1.0f;
static float sz = 36.0f;
static const float TRANS_WIDTH = 36.0f;  // Rectangle width for rendering Transitions
static const float TRANS_HEIGHT = TRANS_WIDTH / 2.0f;  // Rectangle height for rendering Transitions
static const float PLACE_RADIUS = TRANS_WIDTH / 2.0f; // Circle radius for rendering Places
static const float TOKEN_RADIUS = 2.0f;  // Circle radius for rendering tokens
static const float CAPTION_FONT_SIZE = 12;
#define FILL_COLOR(a) IM_COL32(255, 165, 0, (a))
#define OUTLINE_COLOR IM_COL32(165, 42, 42, 255) // Arcs, Places, Transitions
#define CRITICAL_COLOR IM_COL32(255, 0, 0, 255)

static const uint8_t alpha = 255; // FIXME
static float font_size_pixels = 16.0f;
static ImFont* font1 = nullptr;

//------------------------------------------------------------------------------
// helper functions
static inline ImVec2 operator+(const ImVec2 &lhs, const ImVec2 &rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
static inline ImVec2 operator-(const ImVec2 &lhs, const ImVec2 &rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

//------------------------------------------------------------------------------
static inline float norm(const float xa, const float ya, const float xb, const float yb)
{
    return sqrtf((xb - xa) * (xb - xa) + (yb - ya) * (yb - ya));
}

static inline ImVec2 ImRotate(const ImVec2 &v, float cos_a, float sin_a)
{
    return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a);
}

static float random(int lower, int upper)
{
    auto const t = static_cast<unsigned int>(time(NULL));
    srand(t);
    return float(rand() % (upper - lower + 1)) + float(lower);
}

//------------------------------------------------------------------------------
static void about()
{
    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::OpenPopup("About TimedPetriNetEditor");
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("About TimedPetriNetEditor", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("A timed Petri net and graph event editor and");
        ImGui::Text("simulator combined to (max,+) algebra with");
        ImGui::Text("wrapped API for Julia langage.");
        ImGui::Separator();
        std::string version("Version: " +
                            std::to_string(project::info::major_version) + '.' +
                            std::to_string(project::info::minor_version) + '.' +
                            std::to_string(project::info::patch_version));
        ImGui::Text("%s", version.c_str());
        ImGui::Separator();
        ImGui::Text("https://github.com/Lecrapouille/TimedPetriNetEditor");
        ImGui::Text("Git branch: %s", project::info::git_branch.c_str());
        ImGui::Text("Git SHA1: %s", project::info::git_sha1.c_str());
        ImGui::Text("Compiled as %s",
                    (project::info::mode == project::info::Mode::debug)
                    ? "Debug" : "Release");
        ImGui::Separator();
        ImGui::Text("Developed by Quentin Quadrat");
        ImGui::Text("Email: lecrapouille@gmail.com");
        ImGui::Separator();

        if (ImGui::Button("OK", ImVec2(120, 0)))
        {
            ImGui::CloseCurrentPopup();
            show_about = false;
        }

        ImGui::EndPopup();
    }
}

//------------------------------------------------------------------------------
static void help()
{
    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::OpenPopup("Help TimedPetriNetEditor");
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("Help TimedPetriNetEditor", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
        if (ImGui::BeginTabBar("help", tab_bar_flags))
        {
            if (ImGui::BeginTabItem("Mouse actions"))
            {
                std::stringstream help;
                help << "Left button pressed: add a place" << std::endl
                     << "Right button pressed: add a transition" << std::endl
                     << "Middle button pressed: add an arc with the selected place or transition as origin" << std::endl
                     << "Middle button release: end the arc with the selected place or transition as destination" << std::endl
                     << "Middle button pressed: move the view is no place or transitions are selected" << std::endl;

                ImGui::Text("%s", help.str().c_str());
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Keyboard actions"))
            {
                std::stringstream help;
                help << "Not yet implemented" << std::endl;

                ImGui::Text("%s", help.str().c_str());
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Pathes"))
            {
                ImGui::Text("Data path: %s", project::info::data_path.c_str());
                ImGui::Text("Temporary path: %s", project::info::tmp_path.c_str());
                ImGui::Text("Log path: %s", project::info::log_path.c_str());
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }

        if (ImGui::Button("OK", ImVec2(120, 0)))
        {
            ImGui::CloseCurrentPopup();
            show_help = false;
        }

        ImGui::EndPopup();
    }
}

//------------------------------------------------------------------------------
static void console(Editor& editor)
{
    ImGui::Begin("Console");
    ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 6.f);
    if (ImGui::Button("Clear##console_clear")) {
        editor.clearLogs();
    }

    ImGui::PopStyleVar();
    ImGui::Spacing();
    auto const& logs = editor.getLogs();
    size_t i = logs.size();
    while (i--)
    {
        ImGui::Separator();
        if (logs[i].level == Messages::Level::Info)
        {
            ImGui::TextColored(ImVec4(0, 255, 0, 255), "%s[info]: %s",
                               logs[i].time.c_str(), logs[i].message.c_str());
        }
        else if (logs[i].level == Messages::Level::Error)
        {
            ImGui::TextColored(ImVec4(255, 0, 0, 255), "%s[error]: %s",
                               logs[i].time.c_str(), logs[i].message.c_str());
        }
        else
        {
            ImGui::TextColored(ImVec4(255, 0, 255, 255), "%s[warn]: %s",
                               logs[i].time.c_str(), logs[i].message.c_str());
        }
    }
    ImGui::End();
}

//------------------------------------------------------------------------------
static void messagebox(Editor const& editor)
{
    ImGui::Begin("Message");
    ImGui::Text("%s", editor.getError().c_str()); // FIXME: by copy
    ImGui::End();
}

//------------------------------------------------------------------------------
static void inputInteger(std::string const& title, size_t& tokens)
{
    ImGui::AlignTextToFramePadding();
    ImGui::Text("%zu", tokens);
    ImGui::SameLine();

    float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
    ImGui::PushButtonRepeat(true);
    if (ImGui::ArrowButton("##left", ImGuiDir_Left))
    {
        tokens = std::max(size_t(1), tokens);
        --tokens;
    }
    ImGui::SameLine(0.0f, spacing);
    if (ImGui::ArrowButton("##right", ImGuiDir_Right))
    {
        tokens = std::min(Net::Settings::maxTokens, ++tokens);
    }
    ImGui::PopButtonRepeat();
    ImGui::SameLine();
    ImGui::Text("%s", title.c_str());
}

//------------------------------------------------------------------------------
static void inspector(Editor& editor)
{
    // Do not allow editing when running simulation
    const auto readonly = editor.m_simulating ? ImGuiInputTextFlags_ReadOnly : ImGuiInputTextFlags_None;

    // Place captions and tokens
    {
        ImGui::Begin("Places");
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
        ImGui::Checkbox(show_place_captions ? "Show place identifiers" : "Show place captions", &show_place_captions);
        ImGui::PopStyleVar();

        ImGui::Separator();

        // TODO pour event graph: afficher ImGui::InputText("T1 P0 T2", &p.places);
        ImGui::Text("%s", "Captions:");
        for (auto& place: editor.m_net.places())
        {
            ImGui::InputText(place.key.c_str(), &place.caption, readonly);
        }

        ImGui::Separator();
        ImGui::Text("%s", "Tokens:");
        for (auto& place: editor.m_net.places())
        {
            inputInteger(show_place_captions ? place.caption.c_str() : place.key.c_str(), place.tokens);
        }

        ImGui::End();
    }

    // Transition captions and GRAFCET transitivities
    {
        // FIXME parse and clear sensors if and only if we modified entrytext
        ImGui::Begin("Transitions");
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
        ImGui::Checkbox(show_transition_captions ? "Show transition identifiers" : "Show transition captions", &show_transition_captions);
        ImGui::DragFloat("Thickness", &thickness, 0.05f, 1.0f, 8.0f, "%.02f");
        ImGui::DragFloat("Size", &sz, 0.2f, 2.0f, 100.0f, "%.0f");
        ImGui::PopStyleVar();
        ImGui::Separator();
        //if (!editor.m_simulating)
        //    editor.m_net.m_sensors.clear();
        ImGui::Text("%s", "Captions:");
        for (auto& transition: editor.m_net.transitions())
        {
            ImGui::InputText(transition.key.c_str(), &transition.caption, readonly);
            if (!editor.m_simulating)
            {
                //std::string err = editor.m_net.parse(transition, true);
                //if (!err.empty())
                //{
                //    ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "%s", err.c_str());
                //}
            }
        }
        ImGui::End();

        //ImGui::Begin("Sensors");
        //for (auto const& it: editor.m_net.m_sensors.database())
        //{
        //    ImGui::SliderInt(it.first.c_str(), &it.second, 0, 1);
        //}
        //ImGui::End();
    }

    // Arc durations
    {
        ImGui::Begin("Arcs");
        ImGui::Text("%s", "Durations:");
        for (auto& arc: editor.m_net.arcs())
        {
            if (arc.from.type == Node::Type::Transition)
            {
                std::string text(arc.from.key + " -> " + arc.to.key);
                ImGui::InputFloat(text.c_str(), &arc.duration, 0.01f, 1.0f, "%.3f", readonly);
            }
        }
        ImGui::End();
    }
}

//------------------------------------------------------------------------------
static void menu(Editor& editor)
{
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("New", nullptr, false)) {
                // TODO
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Open", nullptr, false)) {
                do_load = true;
            }
            if (ImGui::BeginMenu("Import"))
            {
                // TODO
                ImGui::EndMenu();
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Save", nullptr, false))
            {
                if (editor.m_net.filename() == "") {
                    do_save_as = true;
                } else {
                    editor.m_net.saveAs(editor.m_net.filename());
                }
            }
            if (ImGui::MenuItem("Save As", nullptr, false)) {
                do_save_as = true;
            }
            if (ImGui::BeginMenu("Export to"))
            {
                for (auto const& it: exporters)
                {
                    if (ImGui::MenuItem(it.format.c_str(), nullptr, false))
                    {
                        do_export_to = &it;
                    }
                }
                ImGui::EndMenu();
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Exit", nullptr, false)) {
                editor.close();
            }
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Actions"))
        {
            if (ImGui::BeginMenu("Type of net"))
            {
                static int current_type = int(editor.m_net.type());

                ImGui::RadioButton("Petri net", &current_type, 0);
                ImGui::RadioButton("Timed Petri net", &current_type, 1);
                ImGui::RadioButton("Timed event graph", &current_type, 2);
                ImGui::RadioButton("GRAFCET", &current_type, 3);
                editor.changeTypeOfNet(TypeOfNet(current_type));
                ImGui::EndMenu();
            }
            ImGui::Separator();

            if (ImGui::MenuItem("Clear net", nullptr, false)) {
                editor.clear();
            }
            if (ImGui::MenuItem("Align nodes", nullptr, false))
            {}//editor.align();
            if (ImGui::MenuItem("Show grid", nullptr, false)) {
                editor.m_layout_config.grid.enable ^= true;
            }
            if (ImGui::MenuItem("Take screenshot", nullptr, false))
            {
                do_screenshot = true;
            }
            ImGui::Separator();
            if (ImGui::MenuItem(editor.m_simulating ? "Stop simulation" : "Start simulation", nullptr, false))
            {
                editor.toogleStartSimulation();
            }
            ImGui::EndMenu();
        }

        if ((editor.m_net.type() == TypeOfNet::TimedEventGraph) ||
            (isEventGraph(editor.m_net)))
        {
            if (ImGui::BeginMenu("Graph Events"))
            {
                if (ImGui::MenuItem("Show critical circuit", nullptr, false))
                {
                    do_find_critical_cycle = true;
                }
                if (ImGui::MenuItem("Show (max, +) dynamic linear system", nullptr, false))
                {
                    do_syslin = true;
                }
                if (ImGui::MenuItem("Show Dater equation", nullptr, false))
                {
                    do_dater = true;
                }
                if (ImGui::MenuItem("Show Counter equation", nullptr, false))
                {
                    do_counter = true;
                }
                if (ImGui::MenuItem("Show adjacency matrices", nullptr, false))
                {
                    do_adjency = true;
                }
                ImGui::EndMenu();
            }
        }
        if (ImGui::BeginMenu("Help"))
        {
            if (ImGui::MenuItem("Help", nullptr, false)) {
                show_help = true;
            }
            ImGui::Separator();
            if (ImGui::MenuItem("About", nullptr, false)) {
                show_about = true;
            }
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }

    if (show_help) { help(); }
    if (show_about) { about(); }
    if (do_load) { editor.load(); }
    if (do_save_as) { editor.saveAs(); }
    if (do_export_to != nullptr) { editor.exportTo(*do_export_to); }
    if (do_screenshot) { editor.screenshot(); }

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();

    if (do_adjency)
    {
        ImGui::OpenPopup("Show adjacency matrices");
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal("Show adjacency matrices",
                                   NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Dense matrix", &SparseMatrix<double>::display_as_dense);
            SparseMatrix<double>::display_for_julia = false;
            ImGui::PopStyleVar();

            SparseMatrix<double> tokens; SparseMatrix<double> durations;
            toAdjacencyMatrices(editor.m_net, tokens, durations);

            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("adjacency", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("Durations"))
                {
                    std::stringstream txt; txt << durations;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Tokens"))
                {
                    std::stringstream txt; txt << tokens;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }

            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_adjency = false;
            }
            ImGui::EndPopup();
        }
    }

    if (do_counter || do_dater)
    {
        const char* title = do_counter ? "Counter Equation": "Dater Equation";
        ImGui::OpenPopup(title);
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal(title, NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            static bool use_caption = false;
            static bool maxplus_notation = false;
            static bool show_matrix = false;
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox(do_counter ? "Use (min,+) operator" : "Use (max,+) operator", &maxplus_notation);
            ImGui::SameLine();
            ImGui::Checkbox("Use caption", &use_caption);
            ImGui::PopStyleVar();

            ImGui::Separator();
            if (do_counter)
            {
                ImGui::Text("%s", showCounterEquation(editor.m_net, "", use_caption, maxplus_notation).str().c_str());
            }
            else
            {
                ImGui::Text("%s", showDaterEquation(editor.m_net, "", use_caption, maxplus_notation).str().c_str());
            }

            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_counter = do_dater = false;
            }
            ImGui::EndPopup();
        }
    }

    if (do_syslin)
    {
        ImGui::OpenPopup("(max, +) dynamic linear system");
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal("(max, +) dynamic linear system", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Dense matrix", &SparseMatrix<double>::display_as_dense);
            ImGui::PopStyleVar();

            SparseMatrix<double> D; SparseMatrix<double> A; SparseMatrix<double> B; SparseMatrix<double> C;
            toSysLin(editor.m_net, D, A, B, C);
            SparseMatrix<double>::display_for_julia = false;
            ImGui::Text(u8"%s", "X(n) = D . X(n) ⨁ A . X(n-1) ⨁ B . U(n)\nY(n) = C . X(n)");
            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("syslin", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("D"))
                {
                    std::stringstream txt; txt << D;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("A"))
                {
                    std::stringstream txt; txt << A;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("B"))
                {
                    std::stringstream txt; txt << B;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("C"))
                {
                    std::stringstream txt; txt << C;
                    ImGui::Text("%s", txt.str().c_str());
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }

            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_syslin = false;
            }
            ImGui::EndPopup();
        }
    }

    if (do_find_critical_cycle)
    {
        ImGui::OpenPopup("Critical Cycle");
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
        if (ImGui::BeginPopupModal("Critical Cycle", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            CriticalCycleResult critical_cycle = findCriticalCycle(editor.m_net);
            if (!critical_cycle.success)
            {
                ImGui::Text(u8"%s", critical_cycle.message.str().c_str());
            }
            else
            {
                ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
                if (ImGui::BeginTabBar("CriticalCycleResult", tab_bar_flags))
                {
                    if (ImGui::BeginTabItem("Critical cycle"))
                    {
                        std::stringstream txt;
                        if (editor.m_net.type() == TypeOfNet::TimedEventGraph)
                        {
                            // Only show transitions
                            for (auto const& it: critical_cycle.arcs)
                            {
                                if (it->from.type == Node::Type::Transition)
                                    txt << it->from.key << " -> ";
                                if (it->to.type == Node::Type::Transition)
                                    txt << it->to.key << std::endl;
                            }
                        }
                        else
                        {
                            // Show transitions and places
                            for (auto const& it: critical_cycle.arcs)
                            {
                                txt << it->from.key << " -> " << it->to.key << std::endl;
                            }
                        }
                        ImGui::Text("%s", txt.str().c_str());
                        ImGui::EndTabItem();
                    }
                    if (ImGui::BeginTabItem("Cycle time"))
                    {
                        const auto& tr = editor.m_net.transitions();
                        std::stringstream txt;
                        for (size_t i = 0u; i < critical_cycle.cycle_time.size(); ++i)
                        {
                            txt << tr[i].key << ": " << critical_cycle.cycle_time[i]
                                << " unit of time" << std::endl;
                        }
                        ImGui::Text("%s", txt.str().c_str());
                        ImGui::EndTabItem();
                    }
                    if (ImGui::BeginTabItem("Eigenvector"))
                    {
                        std::stringstream txt;
                        for (auto const& it: critical_cycle.eigenvector)
                        {
                            txt << it << std::endl;
                        }
                        ImGui::Text("%s", txt.str().c_str());
                        ImGui::EndTabItem();
                    }
                    ImGui::EndTabBar();
                }
            }

            ImGui::Separator();
            if (ImGui::Button("OK", ImVec2(120, 0)))
            {
                ImGui::CloseCurrentPopup();
                do_find_critical_cycle = false;
            }
            ImGui::EndPopup();
        }
    }
}

//--------------------------------------------------------------------------
Editor::Editor(size_t const width, size_t const height,
               std::string const& title, std::string const& filename)
    : Application(width, height, title), m_filename(filename),
      m_simulation(m_net, m_simulating, m_messages)
{}

//------------------------------------------------------------------------------
void Editor::onStartUp()
{
    if (!m_filename.empty())
    {
        if (m_net.load(m_filename))
        {
            m_messages.setInfo("loaded with success " + m_filename);
        }
        else
        {
            m_messages.setError(m_net.error());
        }
    }
}

//------------------------------------------------------------------------------
void Editor::reshape()
{
    // ImDrawList API uses screen coordinates!
    canvas_p0 = ImGui::GetCursorScreenPos();
    // Resize canvas to what's available
    canvas_sz = ImGui::GetContentRegionAvail();
    if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;
    if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;
    canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Lock scrolled origin
    origin = ImVec2(canvas_p0.x + scrolling.x, canvas_p0.y + scrolling.y);
}

//------------------------------------------------------------------------------
void Editor::drawGrill()
{
    draw_list->ChannelsSetCurrent(0); // Background
    draw_list->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(50, 50, 50, 255));
    ImU32 color = m_simulating ? IM_COL32(0, 255, 0, 255) : IM_COL32(255, 255, 255, 255);
    draw_list->AddRect(canvas_p0, canvas_p1, color);

    if (!m_layout_config.grid.enable)
        return ;

    const float step = m_layout_config.grid.step;
    for (float x = fmodf(scrolling.x, step); x < canvas_sz.x; x += step)
    {
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y),
                           ImVec2(canvas_p0.x + x, canvas_p1.y),
                           IM_COL32(200, 200, 200, 40));
    }

    for (float y = fmodf(scrolling.y, step); y < canvas_sz.y; y += step)
    {
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y),
                           ImVec2(canvas_p1.x, canvas_p0.y + y),
                           IM_COL32(200, 200, 200, 40));
    }
}

//------------------------------------------------------------------------------
void Editor::drawPetriNet()
{
    static bool open;
    if (!ImGui::Begin("Petri net: foo bar", &open))
    {
        ImGui::End();
        return;
    }

    reshape();
    onHandleInput();

    draw_list = ImGui::GetWindowDrawList();
    draw_list->ChannelsSplit(2);

    draw_list->PushClipRect(canvas_p0, canvas_p1, true);

    drawGrill();

    // Update node positions the user is moving
    for (auto& it: m_selected_modes)
    {
        it->x = m_mouse.x;
        it->y = m_mouse.y;
    }

    for (auto const& it: m_net.arcs())
        drawArc(it);

    for (auto const& it: m_net.places())
        drawPlace(it);

    for (auto const& it: m_net.transitions())
        drawTransition(it);

    // Draw all tokens transiting from Transitions to Places
    for (auto const& at: m_simulation.timedTokens())
        drawToken(at.x, at.y);

    // Draw critical cycle
    //for (auto& a: m_marked_arcs)
    //    draw(*a, 255);

    draw_list->PopClipRect();

    ImGui::End();
}

//------------------------------------------------------------------------------
void Editor::onUpdate(float const dt)
{
    m_simulation.step(dt);
}

//------------------------------------------------------------------------------
void Editor::onDraw()
{
#if 0
    if (m_net.modified)
    {
        m_renderer.setTitle(m_title + " **");
    }
    else
    {
        m_renderer.setTitle(m_title);
    }
#endif

    ImGui::DockSpaceOverViewport();

    ::tpne::menu(*this);
    ::tpne::console(*this);
    ::tpne::messagebox(*this);
    ::tpne::inspector(*this);
    ImGui::ShowDemoWindow();

    drawPetriNet();
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
static void drawArrow(ImDrawList* draw_list, const float xa, const float ya,
                      const float xb, const float yb, const ImU32 color)
{
    // Orientation
    const float teta = (yb - ya) / (xb - xa);
    const float arrowAngle = std::atan(teta);
    const float cos_a = std::cos(arrowAngle);
    const float sin_a = std::sin(arrowAngle);

    // Arc magnitude
    const float arrowLength = norm(xa, ya, xb, yb);

    // Reduce the arrow magnitude to avoid entering in the place and having
    // a mush of pixels when multiple arrows are pointing on the same
    // position. To get full scaled arrow comment this block of code and
    // uncomment xa, xb, ya, yb and tailSize.
    const float r = arrowLength - PLACE_RADIUS;
    const float dx = ((xb - xa) * r) / arrowLength;
    const float dy = ((yb - ya) * r) / arrowLength;
    const float a1 = xb - dx;
    const float b1 = yb - dy;
    const float a2 = xa + dx;
    const float b2 = ya + dy;

    // Head of the arrow
    const ImVec2 arrowHeadSize(14.0f, 14.0f);
    std::vector<ImVec2> points = {
        ImVec2(a2, b2 /*xb, yb*/) + ImRotate(ImVec2(0.0f, 0.0f), cos_a, sin_a),
        ImVec2(a2, b2 /*xb, yb*/) + ImRotate(ImVec2(arrowHeadSize.x, arrowHeadSize.y / 2.0f), cos_a, sin_a),
        ImVec2(a2, b2 /*xb, yb*/) + ImRotate(ImVec2(0.0f, arrowHeadSize.y), cos_a, sin_a)
    };
    draw_list->AddConvexPolyFilled(points.data(), points.size(), color);

    // Tail of the arrow.
    //const sf::Vector2f tailSize{ arrowLength - arrowHeadSize.x, 2.f };
    const ImVec2 tailSize(r - arrowHeadSize.x - 15.0f, 2.0f);
    draw_list->AddLine(ImVec2(xa, ya), ImVec2(xb, yb), color, 2.0f);
}

//------------------------------------------------------------------------------
void Editor::drawArc(Arc const& arc)
{
    ImU32 color;

    if (alpha >= 0u)
    {
        color = FILL_COLOR(alpha);
    }
    else
    {
        // hack to show critical cycles
        color = CRITICAL_COLOR;
    }

    if (m_net.type() == TypeOfNet::TimedEventGraph)
    {
        // In graph event we "compress" the graph by not displaying places.
        if (arc.from.type == Node::Type::Place)
            return ;

        // We draw arrows between Transition to Transition using the
        // property of graph event: there is only one place between them.
        assert((arc.to.arcsOut.size() == 1u) && "malformed graph event");
        Node& next = arc.to.arcsOut[0]->to;
        drawArrow(draw_list,
                  origin.x + arc.from.x,
                  origin.y + arc.from.y,
                  origin.x + next.x,
                  origin.y + next.y,
                  color);

        // Print the timing / tokens
        float x = origin.x + arc.from.x + (next.x - arc.from.x) / 2.0f;
        float y = origin.y + arc.from.y + (next.y - arc.from.y) / 2.0f;
        std::stringstream stream;
        stream << std::fixed << std::setprecision(2) << arc.duration << ", "
               << arc.to.key << "(" << reinterpret_cast<Place&>(arc.to).tokens << ")";
        draw_list->AddText(ImVec2(x, y), IM_COL32(0, 0, 0, 255), stream.str().c_str());
    }
    else
    {
        // Transition -> Place
        drawArrow(draw_list,
                  origin.x + arc.from.x,
                  origin.y + arc.from.y,
                  origin.x + arc.to.x,
                  origin.y + arc.to.y, color);

        if ((arc.from.type == Node::Type::Transition) && (m_net.type() == TypeOfNet::TimedPetriNet))
        {
            // Print the timing for timed petri net
            float x = origin.x + arc.from.x + (arc.to.x - arc.from.x) / 2.0f;
            float y = origin.y + arc.from.y + (arc.to.y - arc.from.y) / 2.0f - 15.0f;
            std::stringstream stream;
            stream << std::fixed << std::setprecision(2) << arc.duration;
            draw_list->AddText(ImVec2(x, y), IM_COL32(0, 0, 0, 255), stream.str().c_str());
        }
    }
}

//------------------------------------------------------------------------------
void Editor::drawToken(float const x, float const y)
{
    draw_list->AddCircleFilled(ImVec2(x, y), TOKEN_RADIUS, IM_COL32(0, 0, 0, 255));
}

// TODO a virer en utilisant un wrapper RenderablePlace avec fading (alpha)
//------------------------------------------------------------------------------
void Editor::drawPlace(Place const& place)
{
    // In graph event we "compress" the graph by not displaying places.
    if (m_net.type() == TypeOfNet::TimedEventGraph)
        return ;

    //const uint8_t alpha = 255; // TODO m_fading[place.key]
    const ImVec2 p = origin + ImVec2(place.x, place.y);

    // Draw the place
    draw_list->AddCircleFilled(p, PLACE_RADIUS, FILL_COLOR(alpha), 64);
    draw_list->AddCircle(p, PLACE_RADIUS, OUTLINE_COLOR, 64);

    // Draw the caption
    ImVec2 dim = ImGui::CalcTextSize(place.key.c_str());
    ImVec2 ptext = p - ImVec2(dim.x / 2.0f, PLACE_RADIUS + dim.y);
    draw_list->AddText(ptext, IM_COL32(0, 0, 0, 255),
                       show_place_captions ? place.caption.c_str() : place.key.c_str());

    // Draw the number of tokens
    if (place.tokens == 0u)
        return ;

    float r = TOKEN_RADIUS;
    float d = TOKEN_RADIUS + 1.0f;

    if (place.tokens == 1u)
    {
        drawToken(p.x, p.y);
    }
    else if (place.tokens == 2u)
    {
        drawToken(p.x - d, p.y);
        drawToken(p.x + d, p.y);
    }
    else if (place.tokens == 3u)
    {
        drawToken(p.x, p.y - r);
        drawToken(p.x - d, p.y + d);
        drawToken(p.x + d, p.y + d);
    }
    else if ((place.tokens == 4u) || (place.tokens == 5u))
    {
        if (place.tokens == 5u)
        {
            d = r + 3.0f;
            drawToken(p.x, p.y);
        }

        drawToken(p.x - d, p.y - d);
        drawToken(p.x + d, p.y - d);
        drawToken(p.x - d, p.y + d);
        drawToken(p.x + d, p.y + d);
    }
    else
    {
        std::string tokens = std::to_string(place.tokens);
        draw_list->AddText(ImVec2(p.x, p.y), IM_COL32(0, 0, 0, 255), tokens.c_str());
    }
}

//------------------------------------------------------------------------------
void Editor::drawTransition(Transition const& transition)
{
    //const uint8_t alpha = 255; // TODO m_fading[place.key]
    const ImVec2 p = origin + ImVec2(transition.x, transition.y);

    // Color of the transition: green if validated else yellow if enabled
    // else color is fadding value.
    ImU32 color;
    if ((m_net.type() == TypeOfNet::PetriNet) && (transition.isValidated()))
    {
        color = IM_COL32(255, 0, 0, 255);
    }
    else
    {
        color = FILL_COLOR(transition.isEnabled() ? 0 : alpha);
    }

    // Draw the transition
    const ImVec2 pmin(p.x - TRANS_WIDTH / 2.0f, p.y - TRANS_HEIGHT / 2.0f);
    const ImVec2 pmax(p.x + TRANS_WIDTH / 2.0f, p.y + TRANS_HEIGHT / 2.0f);
    draw_list->AddRectFilled(pmin, pmax, color);
    const float rounding = sz / 5.0f;
    draw_list->AddRect(pmin, pmax, OUTLINE_COLOR, rounding, ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBottomRight, thickness);

    // Draw the caption
    ImVec2 dim = ImGui::CalcTextSize(transition.key.c_str());
    ImVec2 ptext = p - ImVec2(dim.x / 2.0f, TRANS_HEIGHT + dim.y);
    draw_list->AddText(ptext, IM_COL32(0, 0, 0, 255),
                       show_transition_captions ? transition.caption.c_str() : transition.key.c_str());
}

//------------------------------------------------------------------------------
void Editor::clear()
{
    m_simulating = false;
    m_net.clear(m_net.type());
    //TODO m_animated_tokens.clear();
}

//------------------------------------------------------------------------------
void Editor::toogleStartSimulation()
{
    m_simulating = m_simulating ^ true;

    // Note: in GUI.cpp in the Application constructor, I set
    // the window to have slower framerate in the aim to have a
    // bigger discrete time and therefore AnimatedToken moving
    // with a bigger step range and avoid them to overlap when
    // i.e. two of them, carying 1 token, are arriving at almost
    // the same moment but separated by one call of this method
    // update() producing two AnimatedToken carying 1 token that
    // will be displayed at the same position instead of a
    // single AnimatedToken carying 2 tokens.
    framerate(m_simulating ? 30 : 60); // FPS
}

//------------------------------------------------------------------------------
bool Editor::changeTypeOfNet(TypeOfNet const type)
{
    if (m_simulating)
        return false;

    std::vector<Arc*> arcs;
    if (m_net.convertTo(type, arcs))
        return true;

    m_messages.setError(m_net.error());
    return false;
}

//------------------------------------------------------------------------------
Node* Editor::getNode(float const x, float const y)
{
    Node *n = getPlace(x, y);
    if (n != nullptr)
        return n;
    return getTransition(x, y);
}

//------------------------------------------------------------------------------
Place* Editor::getPlace(float const x, float const y)
{
    for (auto &p : m_net.places())
    {
        float d2 = (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y);
        if (d2 < PLACE_RADIUS * PLACE_RADIUS)
        {
            return &p;
        }
    }

    return nullptr;
}

//------------------------------------------------------------------------------
Transition* Editor::getTransition(float const x, float const y)
{
    for (auto &t : m_net.transitions())
    {
        float d2 = (t.x - x) * (t.x - x) + (t.y - y) * (t.y - y);
        if (d2 < TRANS_WIDTH * TRANS_WIDTH)
        {
            return &t;
        }
    }

    return nullptr;
}

//------------------------------------------------------------------------------
void Editor::load()
{
    if (m_simulating)
    {
        m_messages.setError("Cannot load during the simulation!");
        return ;
    }

    ImGuiFileDialog::Instance()->OpenDialog("ChooseFileDlgKey",
                                            "Choose the Petri file to load",
                                            ".json", ".", 1, nullptr,
                                            ImGuiFileDialogFlags_Modal);

    if (ImGuiFileDialog::Instance()->Display("ChooseFileDlgKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            if (m_net.load(ImGuiFileDialog::Instance()->GetFilePathName()))
            {
                m_messages.setInfo("loaded with success " +
                                   ImGuiFileDialog::Instance()->GetFilePathName());
            }
            else
            {
                m_messages.setError(m_net.error());
            }
        }
        //else
        //{
        //    m_messages.setError("No selected file for loading");
        //}

        // close
        do_load = false;
        ImGuiFileDialog::Instance()->Close();
    }
}

//------------------------------------------------------------------------------
void Editor::exportTo(Exporter const& exporter)
{
    if (m_simulating)
    {
        m_messages.setError("Cannot save during the simulation!");
        return ;
    }

    ImGuiFileDialog::Instance()->OpenDialog("ChooseFileDlgKey",
                                            "Choose the Petri file to save",
                                            exporter.extensions.c_str(), ".", 1, nullptr, // nullptr, m_net.filename() + ".json", 1, nullptr,
                                            ImGuiFileDialogFlags_Modal | ImGuiFileDialogFlags_ConfirmOverwrite);

    if (ImGuiFileDialog::Instance()->Display("ChooseFileDlgKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            auto const path = ImGuiFileDialog::Instance()->GetFilePathName();
            std::string error = exporter.exportFct(m_net, path);
            if (error.empty())
            {
                m_messages.setInfo("saved with success '" + path + "'");
            }
            else
            {
                m_messages.setError(error);
            }
        }

        // close.
        do_save_as = false;
        do_export_to = nullptr; // FIXME think proper code: export vs save as
        ImGuiFileDialog::Instance()->Close();
    }
}

//------------------------------------------------------------------------------
void Editor::saveAs()
{
    static Exporter exporter{"TimedPetriNetEditor", ".json", exportToJSON};
    exportTo(exporter);
}

//------------------------------------------------------------------------------
void Editor::screenshot()
{
    std::string path;
    ImGuiFileDialog::Instance()->OpenDialog("ChooseFileDlgKey",
                                            "Choose the PNG file to save the screenshot",
                                            ".png", ".", 1, nullptr,
                                            ImGuiFileDialogFlags_Modal | ImGuiFileDialogFlags_ConfirmOverwrite);

    if (ImGuiFileDialog::Instance()->Display("ChooseFileDlgKey"))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            path = ImGuiFileDialog::Instance()->GetFilePathName();
            if (Application::screenshot(path))
            {
                m_messages.setInfo("Screenshot taken as file '" + path + "'");
            }
            else
            {
                m_messages.setError("Failed to save screenshot to file '" + path + "'");
            }
        }

        // close.
        do_screenshot = false;
        ImGuiFileDialog::Instance()->Close();
    }
}

//------------------------------------------------------------------------------
void Editor::close()
{
}

//------------------------------------------------------------------------------
void Editor::onDragged(ImVec2 const &mouse_delta)
{
    scrolling.x += mouse_delta.x;
    scrolling.y += mouse_delta.y;
}

//------------------------------------------------------------------------------
ImVec2 Editor::getMousePosition()
{
    ImGuiIO &io = ImGui::GetIO();
    return ImVec2(io.MousePos.x - origin.x, io.MousePos.y - origin.y);
}

//------------------------------------------------------------------------------
bool Editor::IsMouseClicked(ImGuiMouseButton& key, bool& dragging)
{
    ImGuiIO &io = ImGui::GetIO();
    if ((io.MousePos.x >= canvas_p0.x) && (io.MousePos.x <= canvas_p1.x) &&
        (io.MousePos.y >= canvas_p0.y) && (io.MousePos.y <= canvas_p1.y))
    {
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            key = ImGuiMouseButton_Middle;
            if (getNode(m_mouse.x, m_mouse.y) != nullptr)
                disable_dragging = true;
            dragging = false;
            return true;
        }
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            key = ImGuiMouseButton_Left;
            dragging = false;
            return true;
        }
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Right))
        {
            key = ImGuiMouseButton_Right;
            dragging = false;
            return true;
        }

        const float mouse_threshold_for_pan = m_layout_config.grid.menu ? -1.0f : 0.0f;
        if (!disable_dragging)
        {
            if (ImGui::IsMouseDragging(ImGuiMouseButton_Middle, mouse_threshold_for_pan))
            {
                key = ImGuiMouseButton_Middle;
                dragging = true;
                return true;
            }
        }
    }

    return false;
}

//------------------------------------------------------------------------------
bool Editor::IsMouseReleased(ImGuiMouseButton& key)
{
    ImGuiIO &io = ImGui::GetIO();
    if ((io.MousePos.x >= canvas_p0.x) && (io.MousePos.x <= canvas_p1.x) &&
        (io.MousePos.y >= canvas_p0.y) && (io.MousePos.y <= canvas_p1.y))
    {
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Middle))
        {
            key = ImGuiMouseButton_Middle;
            return true;
        }
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            key = ImGuiMouseButton_Left;
            return true;
        }
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            key = ImGuiMouseButton_Right;
            return true;
        }
    }
    return false;
}

//------------------------------------------------------------------------------
void Editor::handleMoveNode()
{
    if (m_selected_modes.size() == 0u)
    {
        Node* node = getNode(m_mouse.x, m_mouse.y);
        if (node != nullptr)
        {
            m_selected_modes.push_back(node);
            m_net.modified = true;
        }
    }
    else
    {
        m_selected_modes.clear();
    }
}

// A placer dans Grid
//------------------------------------------------------------------------------
void Editor::onHandleInput()
{
    // This will catch our interactions
    ImGui::InvisibleButton("canvas", canvas_sz,
                           ImGuiButtonFlags_MouseButtonLeft |
                           ImGuiButtonFlags_MouseButtonRight |
                           ImGuiButtonFlags_MouseButtonMiddle);

    m_mouse = getMousePosition();
    ImGuiMouseButton button;
    if (ImGui::IsItemActive() && ImGui::IsItemHovered())
    {
        if (IsMouseClicked(button, is_dragging))
        {
            // The 'M' key was pressed. Reset the state but do not add new node!
            if (m_selected_modes.size() != 0u)
            {
                m_node_from = m_node_to = nullptr;
                m_selected_modes.clear();
                if (button == ImGuiMouseButton_Middle)
                    return;
            }

            if (is_dragging)
            {
                ImGuiIO& io = ImGui::GetIO();
                onDragged(io.MouseDelta);
            }
            else if (button == ImGuiMouseButton_Middle)
            {
                handleArcOrigin();
            }
            else
            {
                handleAddNode(button);
            }
        }
    }

    if (IsMouseReleased(button))
    {
        is_dragging = disable_dragging = false;

        // The 'M' key was pressed for moving selected nodes.
        // Reset the state but do not add new node!
        if (m_selected_modes.size() != 0u)
        {
            m_node_from = m_node_to = nullptr;
            m_selected_modes.clear();
            if (button == ImGuiMouseButton_Middle)
            {
                return;
            }
        }

        if (button == ImGuiMouseButton_Middle)
        {
            handleArcDestination();
        }
    }

    if (ImGui::IsItemHovered())
    {
        if (ImGui::IsKeyPressed(KEY_BINDING_MOVE_PETRI_NODE, false))
        {
            handleMoveNode();
        }
        // Run the animation of the Petri net
        else if (ImGui::IsKeyPressed(KEY_BINDING_RUN_SIMULATION) ||
                 ImGui::IsKeyPressed(KEY_BINDING_RUN_SIMULATION_ALT))
        {
            toogleStartSimulation();
        }
    }
}

//------------------------------------------------------------------------------
void Editor::handleAddNode(ImGuiMouseButton button)
{
    // TODO m_marked_arcs.clear();

    if (!m_simulating)
    {
        // Add a new Place or a new Transition only if a node is not already
        // present.
        if (getNode(m_mouse.x, m_mouse.y) == nullptr)
        {
            if (button == ImGuiMouseButton_Left)
                m_net.addPlace(m_mouse.x, m_mouse.y);
            else if (button == ImGuiMouseButton_Right)
                m_net.addTransition(m_mouse.x, m_mouse.y);
        }
    }
    else if (m_net.type() == TypeOfNet::PetriNet)
    {
        // Click to fire a transition
        Transition* transition = getTransition(m_mouse.x, m_mouse.y);
        if (transition != nullptr)
        {
            transition->receptivity ^= true;
        }
    }
}

//------------------------------------------------------------------------------
void Editor::handleArcOrigin()
{
    // TODO m_marked_arcs.clear();
    m_selected_modes.clear();

    // Get a place or a transition from the mouse cursor
    m_node_from = getNode(m_mouse.x, m_mouse.y);
    if (m_node_from == nullptr)
    {
        if ((m_net.places().size() != 0u) || (m_net.transitions().size() != 0u))
        {
            // We do not yet know the type of the destination node so create
            // intermediate information.
            m_click_position = m_mouse;
            m_arc_from_unknown_node = true;
        }
    }

    // Reset states
    m_node_to = nullptr;
}

//------------------------------------------------------------------------------
void Editor::handleArcDestination()
{
    // Finish the creation of the arc (destination node) from the mouse cursor
    m_node_to = getNode(m_mouse.x, m_mouse.y);

    // The user grab no nodes: abort
    if ((m_node_from == nullptr) && (m_node_to == nullptr))
        return;

    // Arc to itself
    if (m_node_from == m_node_to)
        return ;

    // Reached the destination node
    if (m_node_to != nullptr)
    {
        if (m_node_from != nullptr)
        {
            if (m_node_to->type == m_node_from->type)
            {
                // The user tried to link two nodes of the same type: this is
                // forbidden but we allow it by creating the intermediate node
                // of oposing type.
                float x = m_node_to->x + (m_node_from->x - m_node_to->x) / 2.0f;
                float y = m_node_to->y + (m_node_from->y - m_node_to->y) / 2.0f;
                float duration = random(1, 5);
                if (m_node_to->type == Node::Type::Place)
                {
                    Transition &n = m_net.addTransition(x, y);
                    if (!m_net.addArc(*m_node_from, n, duration))
                    {
                        // m_message_bar.setError(m_petri_net.message());
                    }
                    m_node_from = &n;
                }
                else
                {
                    Place &n = m_net.addPlace(x, y);
                    if (!m_net.addArc(*m_node_from, n, duration))
                    {
                        // m_message_bar.setError(m_petri_net.message());
                    }
                    m_node_from = &n;
                }
            }
        }
        else
        {
            // The user did not click on a node but released mouse on a node. We
            // create the origin node before creating the arc.
            if (m_arc_from_unknown_node)
            {
                if (m_node_to->type == Node::Type::Place)
                    m_node_from = &m_net.addTransition(m_click_position.x, m_click_position.y);
                else
                    m_node_from = &m_net.addPlace(m_click_position.x, m_click_position.y);
            }
        }
    }
    else if (m_node_from != nullptr)
    {
        // The user did not click on a node but released mouse on a node. We
        // create the origin node before creating the arc.
        float x = m_mouse.x;
        float y = m_mouse.y;
        if (m_net.type() == TypeOfNet::TimedEventGraph)
        {
            // With timed event graph we have to add implicit places.
            float px = x + (m_node_from->x - x) / 2.0f;
            float py = y + (m_node_from->y - y) / 2.0f;
            float duration = random(1, 5);
            Place &n = m_net.addPlace(px, py);
            if (!m_net.addArc(*m_node_from, n, duration))
            {
                // m_message_bar.setError(m_net.message());
            }
            m_node_from = &n;
        }
        if (m_node_from->type == Node::Type::Place)
            m_node_to = &m_net.addTransition(x, y);
        else
            m_node_to = &m_net.addPlace(x, y);
    }
    // Create the arc. Note: the duration value is only used
    // for arc Transition --> Place.
    float duration = random(1, 5);
    if (!m_net.addArc(*m_node_from, *m_node_to, duration))
    {
        // m_message_bar.setError(m_petri_net.message());
    }

    // Reset states
    m_node_from = m_node_to = nullptr;
    m_selected_modes.clear();
    m_arc_from_unknown_node = false;
}

} // namespace tpne
